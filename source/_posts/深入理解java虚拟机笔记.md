---
title: 深入理解java虚拟机笔记
date: 2019-11-05 09:43:29
tags: java
---
- 深入理解java虚拟机摘抄 手打
<!-- more -->

1. #### `java类加载`

```sequence
loading->linking:
Note over linking:verification
Note over linking:preparation
Note over linking:resolution
linking->initialization:
initialization->using:
using->Unloading:
```
`public static int a  = 5`
连接的准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些变量所使用的内存都将在方法去中进行分配.
如上变量`a`在准备阶段过后的初始值是`0`而不是123,因为这时候尚未开始执行任何`java`方法, `123`是在初始化阶段赋值的.
在通常情况下初始值都是零值,但如果变量被`final`修饰,那么准备阶段就会直接赋值为`123`

1. #### `<clinit>`
`<clinit>`方法是有编译器自动收集类中所有类变量的赋值动作和静态语句块重的语句合并产生的.虚拟机会保证一个类的`<clinit>`方法在多线程的环境中被正确的加锁,同步. 

3. #### `类加载器`
比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义,否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，呢么这两个类就必不想等。
双亲委派模型工作过程是: 如果一个类加载器接收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

4. ### `java内存模型(JMM)`
java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存
![JMM模型](https://i.loli.net/2019/11/05/PZWfiK9D6UazXF5.png)
关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝的工作内存，如何从工作内存同步回主碑村之类的是心啊细节，java内存模型中定义了一下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是院子的不可再分的(double和long类型的变量可能有例外).
- lock (锁定)
- unlock (解锁)
- read (读取)
- load (载入)
- use (使用)
- assign (赋值)
- store (存储)
- write (写入)

5. ### `volatile变量规则`
- 第一保证此变量对所有线程的可见性. 
  可见性并不等于原子性 如`i++` 并不能保证并发情况下正确结果
- 禁止指令重排序优化
  
6. ### `java内存区域／java运行时数据区`
![java内存区域](https://i.loli.net/2019/11/05/7G31u4XzfRox2Iy.png)
![java内存区域](https://i.loli.net/2019/11/05/3AbhqxWEdwTYyKC.png)